Component
---------
A class with the @Component() decorator that associates it with a companion template. 
Together, the component and template define a view. A component is a special type of directive. 
The @Component() decorator extends the @Directive() decorator with template-oriented features.

Every Angular application has at least one component, the root component that connects 
a component hierarchy with the page document object model (DOM). 

Each component defines a class that contains application data and logic, 
and is associated with an HTML template that defines a view to be displayed 
in a target environment.

An Angular component class is responsible for exposing data and handling 
most of the view's display and user-interaction logic through data binding.

Loading components
------------------
Most of the ad banner implementation is in ad-banner.component.ts. 
To keep things simple in this example, the HTML is in the @Component decorator's 
template property as a template string.

The <ng-template> element is where you apply the directive you just made. 
To apply the AdDirective, recall the selector from ad.directive.ts, ad-host. 

Apply that to <ng-template> without the square brackets. Now Angular knows where 
to dynamically load components.


Resolving components
--------------------
Take a closer look at the methods in ad-banner.component.ts.

AdBannerComponent takes an array of AdItem objects as input, which ultimately comes 
from AdService. AdItem objects specify the type of component to load and any data to bind 
to the component.AdService returns the actual ads making up the ad campaign.

Passing an array of components to AdBannerComponent allows for a dynamic list of ads without static elements in the template.

With its getAds() method, AdBannerComponent cycles through the array of AdItems and 
loads a new component every 3 seconds by calling loadComponent().


Componenet Selector
---------------------
Before you can add components you have to define an anchor point to tell Angular 
where to insert components.

AdDirective injects ViewContainerRef to gain access to the view container of the element 
that will host the dynamically added component.

In the @Directive decorator, notice the selector name, ad-host; that's what you use 
to apply the directive to the element

ComponentRef
------------
Represents a component created by a ComponentFactory. Provides access to the component instance 
and related objects, and provides the means of destroying the instance.


ElementRef
-----------
The host or anchor element for this component instance.
Angular defines an ElementRef class to wrap render-specific native UI elements. 

In most cases, this allows you to use Angular templates and data binding to access 
DOM elements without reference to the native element.

The documentation generally refers to elements (ElementRef instances), as distinct from 
DOM elements (which can be accessed directly if necessary).

ComponentFactory
----------------
abstract class ComponentFactory<C> {
  abstract selector: string
  abstract componentType: Type<any>
  abstract ngContentSelectors: string[]
  abstract inputs: {...}
  abstract outputs: {...}
  abstract create(injector: Injector, projectableNodes?: any[][], 
rootSelectorOrNode?: any, ngModule?: NgModuleRef<any>): ComponentRef<C>

Directive (control over portion of the browser DOM.)
----------
A class that can modify the structure of the DOM or modify attributes in the DOM 
and component data model. A directive class definition is immediately preceded 
by a @Directive() decorator that supplies metadata.

A directive class is usually associated with an HTML element or attribute, 
and that element or attribute is often referred to as the directive itself. 

When Angular finds a directive in an HTML template, it creates the matching 
directive class instance and gives the instance control over that portion of the browser DOM.

There are three categories of directive:

Components use @Component() (an extension of @Directive()) to associate a template with a class.

Attribute directives modify behavior and appearance of page elements.

Structural directives modify the structure of the DOM.

Template
--------
A template combines HTML with Angular markup that can modify HTML elements before 
they are displayed. Template directives provide program logic, and binding markup connects 
your application data and the DOM. There are two types of data binding:

Event binding 
------------
lets your app respond to user input in the target environment by updating your application data.

Property binding 
---------------
lets you interpolate values that are computed from your application data into the HTML.

Before a view is displayed, Angular evaluates the directives and resolves the binding syntax 
in the template to modify the HTML elements and the DOM, according to your program data and 
logic. Angular supports two-way data binding, meaning that changes in the DOM, such as 
user choices, are also reflected in your program data.

Your templates can use pipes to improve the user experience by transforming values 
for display. For example, use pipes to display dates and currency values that are 
appropriate for a user's locale. Angular provides predefined pipes for common transformations, 
and you can also define your own pipes.

TemplateRef
------------


Template Syntax = Data Binding
--------------


View
----
a view container can contain other view containers
The smallest grouping of display elements that can be created and destroyed together. 
Angular renders a view under the control of one or more directives, 
especially component directives and their companion templates.

Views are typically collected into view hierarchies.
Properties of elements in a view can change dynamically, in response to user actions; 
the structure (number and order) of elements in a view can't. 

You can change the structure of elements by inserting, moving, or removing nested views 
within their view containers

ViewRef
--------


ViewContainerRef
----------------
attached to an anchor element in the hosting component.


View Hierarchy
--------------
A tree of related views that can be acted on as a unit. 
The root view is a component's host view. A host view can be the root of a tree of 
embedded views, collected in a view container (ViewContainerRef) attached to 
an anchor element in the hosting component. 

The view hierarchy is a key part of Angular change detection.

View hierarchies can be loaded and unloaded dynamically as the user navigates through 
the application, typically under the control of a router.

The view hierarchy doesn't imply a component hierarchy. Views that are embedded 
in the context of a particular hierarchy can be host views of other components. 
Those components can be in the same NgModule as the hosting component, or belong to other NgModules.

@ViewChild/@ViewChildren
------------------------


Host View
---------
created by instantiating a component with the createComponent() method
A view that belongs to a component is called a host view

Embedded View
--------------
created by instantiating a TemplateRef with the createEmbeddedView() method

ViewContainerRef
---------------
Represents a container where one or more views can be attached to a component
Can contain host views

ComponentRef
--------------

EmbeddedViewRef
----------------

ElementRef

